\section{Loading CCS}
\begin{verbatim}
Copyright  Andrew Buttefield (c) 2020-21

LICENSE: BSD3, see file LICENSE at ccs2csp root
\end{verbatim}
\begin{code}
module CCSm where
import Data.Maybe
import Data.List
import Data.Set (Set)
import qualified Data.Set as S
import Data.Map (Map)
import qualified Data.Map as M
import Control
import Syntax
import Semantics

-- generated by BNFC from CCS.bnfc
import AbsCCS
import ParCCS

import Debug.Trace
dbg msg x = trace (msg++show x) x
--pdbg nm x = Translate.dbg ("\n@"++nm++":\n") x
\end{code}

\subsection{Introduction}

Here we provide a parser for the Aalborg dialect of machine-readable CCS.

\subsection{CCSm Parsers}

\begin{code}
processParser :: String -> Either String Process
processParser = pProcess . myLexer

programParser :: String -> Either String Program
programParser = pProgram . myLexer
\end{code}

\subsection{CCSm to CCS conversion}

We need to inject the BNFC generated datatypes into ours.
\begin{code}
proc2CCS :: Process -> CCS
proc2CCS (Summation p1 p2)         =  Sum (proc2CCS p1) (proc2CCS p2)
proc2CCS (Composition p1 p2)       =  Comp (proc2CCS p1) (proc2CCS p2)
proc2CCS (Prefix act p)            =  CCSpfx (action2evt act) (proc2CCS p)
proc2CCS (RestrictEnum p lbls)     =  Rstr (lbls2ixlabs lbls) (proc2CCS p)
proc2CCS (RestrictIdent p ident) = error ("RestrictIdent needs name->set maps")
proc2CCS (Rename p relabels)       =  CCSren (rel2rpairs relabels) (proc2CCS p)
proc2CCS Null  =  Zero
proc2CCS (Named (Identifier str))  =  CCSvar str
\end{code}

\begin{code}
action2evt (Input  (Label "tau"))  =  T
action2evt (Input  (Label ell))    =  Lbl (Std ell,None)
action2evt (Output (Label ell))    =  Lbl (Bar ell,None)

rel2rpairs = map rel2rpair
rel2rpair (ToFrom (Label to) (Label from)) = (from,to)

lbls2ixlabs labels = S.fromList $ map lbl2ixlab labels
lbl2ixlab (Label ell) = (Std ell,None)
\end{code}
